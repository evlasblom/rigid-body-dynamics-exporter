% ANIMATION3D Shows an animated model given the simulated data.
%   ANIMATION3D(Model,t,x,...) uses the structure from CreateModel
%   to visualize the state space x, through time t. The result is a 3D
%   animation of the provided model. Note that x here is the state space,
%   but giving only the degrees of freedom q in time, i.e., half of the
%   state space, also suffices. Options are:
%
%   handle:     handle to an axis for visualization
%               handle, created by default
%   export:     save a video of the animation 
%               boolean, default false
%   exportloc:  location to save the video
%               string
%   showworld   show world frame, axes and grid
%               boolean, default false
%   showframe:  show body frames
%               boolean, default false
%   showcom:    show center of mass positions
%               boolean, default false
%   showtime:   show simulation time on top
%               boolean, default false
%   framesize:  size of the body frames
%               double, default 0.05
%   view:       input of the view function used for figures
%               1x2 double, default [45 30]
%   axis:       input of the axis function used for figures
%               1x6 double, default is automatically detected
%   follow:     keep the specified body centered in the figure
%               integer, default 0 (no body)
%   timescale:  speed up visualization by scaling time automatically
%               boolean, default true
%   bgcolor:    rgb values for the background color
%               1x3 double, default [1 1 1]
%   color:      rgb values for the body color
%               1x3 double, default [200 200 250]/255
%   parameters: use the parameter structure to update the animation
%               structure, as generated by RecursiveDynamics
%
% Made by Erik Vlasblom
% Last modified: 16-12-2014
function Animation3D(Model,t_data,q_data,varargin)

% Options
options = struct(...
    'handle',[],...
    'export',false,...
    'exportloc',[],...
    'showworld',false,...
    'showframe',false,...
    'showcom',false,...
    'showtime',false,...
    'framesize',0.05,...
    'view',[45 30],...
    'axis',[],...
    'follow',false,...
    'timescale',true,...
    'bgcolor',[1 1 1],...
    'color',[200 200 250]/255,...
    'parameters',[]);
onames = fieldnames(options);
if ~isempty(varargin)
    nvarargin = length(varargin);
    if mod(nvarargin,2) == 0
        for i = 1:2:nvarargin
            if ~isempty(find(strcmp(onames,varargin{i}),1))
                options.(varargin{i}) = varargin{i+1};
            else
                error(['Input ',varargin{i},' is not a valid option.']);
            end
        end
    else
        error('Please specify all additional input.')
    end
end
saveVideo = options.export;
if ~isempty(options.parameters);  Model = umfp(Model,options.parameters); end

% Initialize
B = Model.rigidbody;
p = Model.connectivity.lambda;
mu = Model.connectivity.mu;
n = Model.dof;

global AnimationFig AxesHandle
if isempty(options.handle)
    AnimationFig = figure('Name',Model.name,'NumberTitle','off', ...
        'Color',options.bgcolor);
    AxesHandle = axes('Parent',AnimationFig,  'Position',[0 0 1 1]);
else AxesHandle = options.handle; 
end

% Video options
if saveVideo
    exploc = options.exportloc;
    if ~isempty(exploc);
        if ~strcmp(exploc(end),'\'); exploc = [options.exportloc,'\']; end;
    end    
    exportloc = [exploc,Model.name,'_video_',datestr(now),'.avi'];
    exportloc = regexprep(exportloc,':','-');
    vidObj = VideoWriter(exportloc);
    open(vidObj);
    set(gca,'nextplot','replacechildren');
    set(gcf,'Renderer','zbuffer');
end

% Create local transforms
q = sym('q',[n 1]);
Hm = struct('f',[]); % transformations to com are functions
Hl = struct('f',[]); % local transformations to com are functions
for k = 1:n
    Hm(k).f = HomogeneousTransformFunction(...
        HomogeneousTransform(B(k).inertial.origin));
    Hl(k).f = HomogeneousTransformFunction(...
        CreateTransform(B(k).joint.type,B(k).joint.axis,B(k).joint.offset,q(k)));
end

% Create bodies
offset = [0 0 0];
offset2 = B(1).joint.offset;
bw = Model.visual.bodywidth;
maxdd = [bw, bw, bw]/2;
mindd = -[bw, bw, bw]/2;
for k = 1:n
    B(k).visual.name = ['body',num2str(k)];
    
    % Obtain body length from transformation to the body's children
    maxd = maxdd; mind = mindd;
    for ii = 1:length(mu{k});
        maxd = max(maxd,B(mu{k}{ii}).joint.offset);
        mind = min(mind,B(mu{k}{ii}).joint.offset);
    end
    
    % Use body properties that are set, else, find body size
    if isempty(B(k).visual.bodysizemax)
         B(k).visual.bodysizemax = maxd;
    end
    if isempty(B(k).visual.bodysizemin)
        B(k).visual.bodysizemin = mind;
    end
    if isempty(B(k).visual.vertices) || isempty(B(k).visual.faces)
        [B(k).visual.vertices,B(k).visual.faces] = ...
            make_cube(B(k).visual.bodysizemin,B(k).visual.bodysizemax);
    end
    
    % Create patches
    cuboid.(B(k).visual.name) = patch('Parent',AxesHandle,...
        'Faces',B(k).visual.faces,'Vertices',B(k).visual.vertices,'FaceColor',options.color);
       
    % Initial configuration  
    offset = offset + B(k).joint.offset;
    offset2 = offset2 + max(B(k).visual.bodysizemax-B(k).visual.bodysizemin);
end
        
% Create base
hasbase = isfield(Model,'base');
maxdd = [bw, bw, bw]/2;
mindd = -[bw, bw, bw]/2;
if hasbase
    base = Model.base;
    base.visual.name = 'base';
    if isempty(base.visual.bodysizemax);
        base.visual.bodysizemax = max(maxdd,B(1).joint.offset);
    end
    if isempty(base.visual.bodysizemin);
        base.visual.bodysizemin = min(mindd,B(1).joint.offset);
    end
    if isempty(base.visual.vertices) || isempty(base.visual.faces)
        [base.visual.vertices,base.visual.faces] = ...
            make_cube(base.visual.bodysizemin,base.visual.bodysizemax);
    end
    cuboid.(base.visual.name) = patch('Parent',AxesHandle,...
        'Faces',base.visual.faces,'Vertices',base.visual.vertices,'FaceColor',options.color);
    offset2 = offset2 + max(base.visual.bodysizemax-base.visual.bodysizemin);
end
offset = offset2;

% Create frames and COM
if options.showworld; frame.I = make_frame('0'); end
for k = 1:n
    if options.showframe; frame.(B(k).visual.name) = make_frame(num2str(k)); end
    
    if options.showcom; com.(B(k).visual.name) = make_com(); end
end

% Create time
if options.showtime
    ttxt = text(0.1,0.9,'t = 0 s','Units','normalized', ...
        'HorizontalAlignment','left','VerticalAlignment','top', ...
        'Color','k','fontweight','bold');
end

axScale = max(abs(offset));
autoAxis = axScale*[-1 1 -1 1 -1 1];
if isempty(options.axis); options.axis = autoAxis; end

material shiny;
alpha('color');

g = @(i,j) ['g',num2str(i),'_',num2str(j)]; 
Hg.(g(0,0)) = eye(4);

if options.timescale; tscale = ceil(length(t_data)/200);
else tscale = 1;
end
tend = max([floor(length(t_data)/tscale),1]);

for i=1:tend 
    t = i*tscale;
    q = q_data(t,:);
    
    for k = 1:n        
        % Global transformations
        Hg.(g(k,0)) = Hg.(g(p{k},0))*Hl(k).f(q(k));
        
        % Update bodies    
        draw_rigidbody(B(k).visual.vertices,Hg.(g(k,0)),cuboid.(B(k).visual.name));
        
        if options.showframe; draw_frame(Hg.(g(k,0)),frame.(B(k).visual.name),options.framesize); end
            
        if options.showcom; draw_com(Hg.(g(k,0))*Hm(k).f(),com.(B(k).visual.name)); end
    end
    if hasbase; draw_rigidbody(base.visual.vertices,eye(4),cuboid.(base.visual.name)); end
    
    if options.showtime; set(ttxt,'String',['t = ',num2str(t_data(t)),' s']); end

    % Figure properties
    if options.follow ~= 0; add = h2p(Hg.(g(options.follow,0)))'; 
    else add = [0 0 0]; end
    view(options.view)
    axis(add([1 1 2 2 3 3]) + options.axis)
    if options.showworld; axis on; grid on; draw_frame(eye(4),frame.I,options.framesize);
    else axis off;
    end
    
    % Save or show
    if ~saveVideo; drawnow; end;
    if saveVideo; writeVideo(vidObj,getframe); end
    
    % Prevent error when closing figure
    if gca ~= AxesHandle
        break
    end
end

if saveVideo; close(vidObj); end


% -------- SUBFUNCTIONS ---------------------------------

% Vertices and faces to make a cube
    function [coordinates, faces] = make_cube(min,max)
        x = min(1);
        y = min(2);
        z = min(3);
        XX = max(1);
        YY = max(2);
        ZZ = max(3);
        coordinates = [x y z;
            x YY z;
            XX YY z;
            XX y z ;
            x y ZZ;
            x YY ZZ;
            XX YY ZZ;
            XX y ZZ];
        faces = [1 2 3 4; ...
            2 6 7 3; ...
            4 3 7 8; ...
            1 5 8 4; ...
            1 2 6 5; ...
            5 6 7 8];
    end

% Make frame objects
    function [frame] = make_frame(k)
        frame.x = line('Parent',AxesHandle, 'Color','r', 'LineWidth',1);
        frame.y = line('Parent',AxesHandle, 'Color','g', 'LineWidth',1);
        frame.z = line('Parent',AxesHandle, 'Color','b', 'LineWidth',1);
        frame.n = text(0,0,k, ...
        'HorizontalAlignment','left','VerticalAlignment','top', ...
        'Color','k','fontweight','bold');
    end

% Make com position objects
    function com = make_com(varargin)
        com.o = line('Parent',AxesHandle, 'Marker','o','MarkerFaceColor','w','MarkerSize',6,'LineWidth',1.5);
        com.x = line('Parent',AxesHandle, 'Marker','x','MarkerSize',4,'LineWidth',1.5);
    end

% Draw rigid body
    function draw_rigidbody(vertices,H,cuboid)
        tmpv = Transform(vertices, H);
        set(cuboid,'Vertices',tmpv);
    end

% Draw frame
    function draw_frame(H,frame,frameSize)
        fror = Transform([0 0 0], H); % frame origin
        frax = Transform([frameSize 0 0], H); % frame x-axis
        set(frame.x,'Xdata',[fror(1) frax(1)],'Ydata',[fror(2) frax(2)],'Zdata',[fror(3) frax(3)]);
        frax = Transform([0 frameSize 0], H); % frame y-axis
        set(frame.y,'Xdata',[fror(1) frax(1)],'Ydata',[fror(2) frax(2)],'Zdata',[fror(3) frax(3)]);
        frax = Transform([0 0 frameSize], H); % frame z-axis
        set(frame.z,'Xdata',[fror(1) frax(1)],'Ydata',[fror(2) frax(2)],'Zdata',[fror(3) frax(3)]);
        set(frame.n,'Position',[fror(1) fror(2) fror(3)]); 
    end

% Draw com position
    function draw_com(H,com)
            set(com.o,'Xdata',H(1,4),'Ydata',H(2,4),'Zdata',H(3,4));
            set(com.x,'Xdata',H(1,4),'Ydata',H(2,4),'Zdata',H(3,4));
    end

end